package cssgen

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"
)

// WriteGoFile generates multiple output .go files split by component
func WriteGoFile(publicClasses []*CSSClass, allClasses []*CSSClass, config Config, stats GenerateResult) error {
	return WriteGoFiles(publicClasses, allClasses, config, stats)
}

// generateAllCSSClassesMap creates a map of all CSS classes found in source files
func generateAllCSSClassesMap(classes []*CSSClass) string {
	// Collect all unique class names (1:1 mapping - just the class name)
	allClassNames := make(map[string]bool)

	for _, class := range classes {
		// Add the class name (1:1 mapping)
		allClassNames[class.Name] = true
	}

	// Sort for deterministic output
	var sortedClasses []string
	for className := range allClassNames {
		sortedClasses = append(sortedClasses, className)
	}
	sort.Strings(sortedClasses)

	// Build the map declaration
	var buf strings.Builder
	buf.WriteString("// AllCSSClasses is a map of all CSS classes found in the source files.\n")
	buf.WriteString("// This is used by the linter to detect invalid class references.\n")
	buf.WriteString("// Generated classes, internal classes, and utility classes are all included.\n")
	buf.WriteString("var AllCSSClasses = map[string]bool{\n")

	for _, className := range sortedClasses {
		fmt.Fprintf(&buf, "\t%q: true,\n", className)
	}

	buf.WriteString("}\n")

	return buf.String()
}

// formatFileHeader generates package declaration and metadata
func formatFileHeader(config Config, stats GenerateResult) string {
	var lines []string

	lines = append(lines, "// Code generated by cssgen. DO NOT EDIT.")
	lines = append(lines, "//")
	lines = append(lines, fmt.Sprintf("// Source: %s", config.SourceDir))
	lines = append(lines, fmt.Sprintf("// Files scanned: %d", stats.FilesScanned))
	lines = append(lines, fmt.Sprintf("// Classes generated: %d", stats.ClassesGenerated))
	lines = append(lines, fmt.Sprintf("// Generated: %s", time.Now().Format("2006-01-02 15:04:05")))
	lines = append(lines, "//")
	lines = append(lines, "// This file provides type-safe constants for CSS classes.")
	lines = append(lines, "// Each constant includes metadata about layer, inheritance, and styles.")

	return strings.Join(lines, "\n")
}

// formatConstant generates a single constant with comment
func formatConstant(class *CSSClass, config Config) string {
	var comment string

	switch config.Format {
	case "compact":
		comment = formatCommentCompact(class)
	case "markdown":
		fallthrough
	default:
		comment = formatCommentMarkdown(class, config)
	}

	// Pure 1:1 mapping: always use class.Name
	value := class.Name

	return fmt.Sprintf("%s\nconst %s = %q\n", comment, class.GoName, value)
}

// formatCommentMarkdown generates markdown-formatted comment
func formatCommentMarkdown(class *CSSClass, config Config) string {
	var lines []string

	// Layer badge
	if class.Layer != "" && class.Layer != "n/a" {
		lines = append(lines, fmt.Sprintf("// @layer %s", class.Layer))
		lines = append(lines, "//")
	}

	// Base class (for modifiers) - add usage context
	if class.ParentClass != nil {
		lines = append(lines, fmt.Sprintf("// **Base:** .%s", class.ParentClass.Name))
		lines = append(lines, fmt.Sprintf("// **Context:** Use with .%s for proper styling", class.ParentClass.Name))
	}

	// Intent (if available)
	if class.Intent != "" {
		lines = append(lines, fmt.Sprintf("// **Intent:** %s", class.Intent))
	}

	// Property diff (for modifiers)
	if class.PropertyDiff != nil {
		addedCount := len(class.PropertyDiff.Added)
		changedCount := len(class.PropertyDiff.Changed)
		if addedCount+changedCount > 0 {
			propNames := []string{}
			for name := range class.PropertyDiff.Changed {
				propNames = append(propNames, name)
			}
			for name := range class.PropertyDiff.Added {
				propNames = append(propNames, name)
			}
			sort.Strings(propNames)
			lines = append(lines, fmt.Sprintf(
				"// **Overrides:** %d properties (%s)",
				addedCount+changedCount,
				strings.Join(propNames, ", "),
			))
		}
	}

	// Blank line before properties
	if len(lines) > 1 {
		lines = append(lines, "//")
	}

	// Categorized properties
	if len(class.Properties) > 0 {
		categorized := categorizeProperties(class.Properties)
		lines = append(lines, formatCategorizedProperties(categorized, config)...)
	}

	// Pseudo-state interactions
	if len(class.PseudoStateProperties) > 0 {
		lines = append(lines, "//")
		lines = append(lines, "// **Interactions:**")
		for _, psp := range class.PseudoStateProperties {
			changes := []string{}
			for prop, val := range psp.Changes {
				// Clean value - remove newlines and excessive whitespace
				cleanVal := strings.ReplaceAll(val, "\n", " ")
				cleanVal = strings.ReplaceAll(cleanVal, "\t", " ")
				// Collapse multiple spaces
				for strings.Contains(cleanVal, "  ") {
					cleanVal = strings.ReplaceAll(cleanVal, "  ", " ")
				}
				cleanVal = strings.TrimSpace(cleanVal)
				changes = append(changes, fmt.Sprintf("%s to `%s`", prop, cleanVal))
			}
			sort.Strings(changes)
			lines = append(lines, fmt.Sprintf(
				"// - `%s`: Changes %s",
				psp.PseudoState,
				strings.Join(changes, ", "),
			))
		}
	}

	return strings.Join(lines, "\n")
}

// formatCommentCompact generates single-line compact comment
func formatCommentCompact(class *CSSClass) string {
	parts := []string{}

	// Layer
	if class.Layer != "" && class.Layer != "n/a" {
		parts = append(parts, fmt.Sprintf("@layer %s", class.Layer))
	}

	// Base
	if class.ParentClass != nil {
		parts = append(parts, fmt.Sprintf("Base: .%s", class.ParentClass.Name))
	}

	// Properties (truncated)
	if len(class.Properties) > 0 {
		props := cleanProperties(class.Properties)
		parts = append(parts, props)
	}

	return "// " + strings.Join(parts, " | ")
}

// formatCategorizedProperties formats properties grouped by category
func formatCategorizedProperties(
	categorized map[PropertyCategory][]CategorizedProperty,
	config Config,
) []string {
	var lines []string

	// Category order (priority)
	categoryOrder := []PropertyCategory{
		CategoryVisual,
		CategoryLayout,
		CategoryTypography,
		CategoryEffects,
	}

	for _, cat := range categoryOrder {
		props, exists := categorized[cat]
		if !exists || len(props) == 0 {
			continue
		}

		// Skip internal properties unless ShowInternal is true
		if cat == CategoryInternal && !config.ShowInternal {
			continue
		}

		// Category header
		lines = append(lines, fmt.Sprintf("// **%s:**", cat))

		// Limit properties per category
		limit := config.PropertyLimit
		if limit == 0 {
			limit = 5 // default
		}

		displayProps := props
		truncated := false
		if len(props) > limit {
			displayProps = props[:limit]
			truncated = true
		}

		// Format each property
		for _, prop := range displayProps {
			emoji := ""
			if prop.IsToken {
				emoji = " ðŸŽ¨" // Token indicator
			}
			// Clean value - remove newlines and excessive whitespace
			cleanValue := strings.ReplaceAll(prop.Value, "\n", " ")
			cleanValue = strings.ReplaceAll(cleanValue, "\t", " ")
			// Collapse multiple spaces to single space
			for strings.Contains(cleanValue, "  ") {
				cleanValue = strings.ReplaceAll(cleanValue, "  ", " ")
			}
			cleanValue = strings.TrimSpace(cleanValue)

			lines = append(lines, fmt.Sprintf(
				"// - %s: `%s`%s",
				prop.Name,
				cleanValue,
				emoji,
			))
		}

		// Show truncation message
		if truncated {
			remaining := len(props) - limit
			lines = append(lines, fmt.Sprintf(
				"// - [+%d more %s properties]",
				remaining,
				strings.ToLower(string(cat)),
			))
		}
	}

	return lines
}

// WriteGoFiles generates multiple output .go files split by component
func WriteGoFiles(publicClasses []*CSSClass, allClasses []*CSSClass, config Config, stats GenerateResult) error {
	// Clean up old generated files before writing new ones
	if err := cleanupOldGeneratedFiles(config.OutputDir); err != nil {
		return fmt.Errorf("cleanup failed: %w", err)
	}

	// Group classes by component
	grouped := groupClassesByComponent(publicClasses, config)

	// Collect component names for table of contents
	var componentNames []string
	for component := range grouped {
		if component != "base" {
			componentNames = append(componentNames, component)
		}
	}
	sort.Strings(componentNames)

	// Write base file (AllCSSClasses + base/utilities layers)
	baseFile := filepath.Join(config.OutputDir, "styles.gen.go")
	if err := writeBaseFile(baseFile, allClasses, grouped["base"], componentNames, config, stats); err != nil {
		return fmt.Errorf("failed to write base file: %w", err)
	}

	// Write component files
	for _, component := range componentNames {
		classes := grouped[component]
		filename := filepath.Join(config.OutputDir, fmt.Sprintf("styles_%s.gen.go", component))
		if err := writeComponentFile(filename, classes, component, config); err != nil {
			return fmt.Errorf("failed to write component file %s: %w", component, err)
		}
	}

	return nil
}

// cleanupOldGeneratedFiles removes old styles_*.gen.go files to prevent stale files
func cleanupOldGeneratedFiles(dir string) error {
	pattern := filepath.Join(dir, "styles_*.gen.go")
	matches, err := filepath.Glob(pattern)
	if err != nil {
		return err
	}

	for _, file := range matches {
		if err := os.Remove(file); err != nil && !os.IsNotExist(err) {
			return fmt.Errorf("failed to remove %s: %w", file, err)
		}
	}

	return nil
}

// groupClassesByComponent groups classes by their source component
func groupClassesByComponent(classes []*CSSClass, config Config) map[string][]*CSSClass {
	grouped := make(map[string][]*CSSClass)

	for _, class := range classes {
		component := inferComponentName(class, config)
		grouped[component] = append(grouped[component], class)
	}

	// Sort classes within each group alphabetically
	for _, classes := range grouped {
		sort.Slice(classes, func(i, j int) bool {
			return classes[i].GoName < classes[j].GoName
		})
	}

	return grouped
}

// inferComponentName extracts component name from source file path
// Refined to handle subdirectories and normalize for Go filenames
func inferComponentName(class *CSSClass, config Config) string {
	// Core/Global files go to base
	if class.Layer == "base" || class.Layer == "utilities" ||
		strings.Contains(class.SourceFile, "app-shell") {
		return "base"
	}

	// Extract path relative to SourceDir to handle subfolders
	// Example: "components/forms/input.css" -> "forms_input"
	rel, err := filepath.Rel(config.SourceDir, class.SourceFile)
	if err != nil {
		// Fallback: use basename
		rel = filepath.Base(class.SourceFile)
	}

	cleanPath := strings.TrimSuffix(rel, filepath.Ext(rel))

	// Normalize for Go filenames
	name := strings.ReplaceAll(cleanPath, string(filepath.Separator), "_")
	name = strings.ReplaceAll(name, "-", "_")

	// Remove "layers/components/" prefix if present
	name = strings.TrimPrefix(name, "layers_components_")
	name = strings.TrimPrefix(name, "components_")

	return name
}

// writeBaseFile writes the main styles.gen.go with AllCSSClasses map + base classes
func writeBaseFile(filename string, allClasses []*CSSClass, baseClasses []*CSSClass, componentNames []string, config Config, stats GenerateResult) error {
	var buf strings.Builder

	// File header
	buf.WriteString(formatFileHeader(config, stats))
	buf.WriteString("\n\n")

	// Package declaration with table of contents
	fmt.Fprintf(&buf, "package %s\n\n", config.PackageName)

	// Table of contents comment
	if len(componentNames) > 0 {
		buf.WriteString("// Package ui provides type-safe CSS constants.\n")
		buf.WriteString("// This package is split into multiple files for readability:\n")
		for _, component := range componentNames {
			buf.WriteString(fmt.Sprintf("// - styles_%s.gen.go\n", component))
		}
		buf.WriteString("//\n")
		buf.WriteString("// This file contains the AllCSSClasses registry and base/utility styles.\n")
		buf.WriteString("\n")
	}

	// AllCSSClasses map
	buf.WriteString(generateAllCSSClassesMap(allClasses))
	buf.WriteString("\n")

	// Base/utility constants
	for _, class := range baseClasses {
		buf.WriteString(formatConstant(class, config))
		buf.WriteString("\n")
	}

	// #nosec G306 - generated file should be readable by all
	return os.WriteFile(filename, []byte(buf.String()), 0644)
}

// writeComponentFile writes a component-specific file (e.g., styles_buttons.gen.go)
func writeComponentFile(filename string, classes []*CSSClass, component string, config Config) error {
	var buf strings.Builder

	// File header
	buf.WriteString(formatComponentFileHeader(component))
	buf.WriteString("\n\n")

	// Package declaration
	fmt.Fprintf(&buf, "package %s\n\n", config.PackageName)

	// Component comment with source reference
	componentTitle := strings.ReplaceAll(component, "_", " ")
	if len(componentTitle) > 0 {
		componentTitle = strings.ToUpper(string(componentTitle[0])) + componentTitle[1:]
	}
	buf.WriteString(fmt.Sprintf("// %s component styles\n", componentTitle))
	buf.WriteString("//\n")
	buf.WriteString("// For the full CSS class registry, see styles.gen.go\n")
	buf.WriteString("\n")

	// Constants
	for _, class := range classes {
		buf.WriteString(formatConstant(class, config))
		buf.WriteString("\n")
	}

	// #nosec G306 - generated file should be readable by all
	return os.WriteFile(filename, []byte(buf.String()), 0644)
}

// formatComponentFileHeader generates header for component files
func formatComponentFileHeader(component string) string {
	var lines []string

	componentTitle := strings.ReplaceAll(component, "_", " ")
	if len(componentTitle) > 0 {
		componentTitle = strings.ToUpper(string(componentTitle[0])) + componentTitle[1:]
	}
	lines = append(lines, "// Code generated by cssgen. DO NOT EDIT.")
	lines = append(lines, "//")
	lines = append(lines, fmt.Sprintf("// Component: %s", componentTitle))
	lines = append(lines, fmt.Sprintf("// Generated: %s", time.Now().Format("2006-01-02 15:04:05")))

	return strings.Join(lines, "\n")
}
